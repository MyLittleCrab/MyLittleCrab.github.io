{"pageProps":{"post":{"title":"Ищем, в каких таблицах используется домен в ABAP","date":"2020-07-12T14:15:07.322Z","slug":"domain_where_used_list","author":{"name":"Roman A. Nosov","picture":"https://avatars3.githubusercontent.com/u/21103635?s=120&v=4","url":"https://github.com/JustAddAcid"},"content":"<p>Какое здесь может быть введение? Продолжаю писать образовательные посты с небольшими вкраплениями абсурда, мемов и ненависти ко всему окружающему. Сегодня пишем утилиту. Под <em>SAP</em>. Своё отношение к разработке на этой платформе высказывал в <a href=\"/posts/zcl-date-abap\">предыдущей статье</a>.</p>\n<p>Конкретно эта программа — очень хороший пример, как сама система вынуждает разработчиков усложнять код и делать костыли, чтобы обойти абсолютно <strong>искусственно</strong> расставленные ограничения. Усаживайтесь поудобнее, мы начинаем!</p>\n<p><img src=\"/assets/blog/domain_where_used_list/device.jpg\" alt=\"Девайсы для abap&#x27;еров\"></p>\n<h2>Немного теории</h2>\n<p><strong>Що таке домени в <em>SAP</em>?</strong></p>\n<p><strong>Домены в SAP</strong> — это то, что <del>нормальные</del> люди называют <em>типами данных</em>. То, как данные представлены непосредственно в памяти программы или <em>СУБД</em>: строка из N символов, int32, int64, float, enum из определенного набора значений и т.д.</p>\n<p>Есть ещё такое понятие в <em>SAP</em>-тусовке как <strong>элемент данных</strong> (<em>data element</em>). Это \"тип данных на максималках\", который содержит в себе <strong>не только</strong> описание того, как эти данные лежат в памяти, но и дополнительные плюшки в виде:</p>\n<ol>\n<li>Дефолтный заголовок этого поля для разных языков (который подтягивается в поле ввода или заголовок таблицы по умолчанию)</li>\n<li>Ссылка на \"средство поиска\" — программу, которая помогает пользователю заполнить input значением. (Например, предоставить выбор из списка контрагентов с заданными параметрами)</li>\n<li>... прочие второстепенные штуки</li>\n</ol>\n<p>Т.е. сначала объявляется домен, от него наследуется элемент данных, который уже используется для объявления переменных/объявления столбцов в таблицах БД.</p>\n<p><img src=\"/assets/blog/domain_where_used_list/data_element.jpg\" alt=\"Схема наследования\"></p>\n<p>Оукей, на первых парах нам этой информации достаточно. Остальное будем понимать по ходу процесса:</p>\n<h2>Процесс</h2>\n<p><strong>Формулируем</strong>, что мы хотим получить в итоге. Программу, которая:</p>\n<ol>\n<li>Принимает на вход <strong>имя домена</strong> и параметр:<ol>\n<li>Считать ли количество строк в таблицах</li>\n</ol></li>\n<li>Выводит список таблиц со следующими полями:<ol>\n<li>Имя таблицы, которая использует введенный домен</li>\n<li>Название поля таблицы</li>\n<li>Имя элемента данных этого поля</li>\n<li>Количество строк <strong>или</strong> результат проверки на пустоту (в зависимости от входного параметра) </li>\n</ol></li>\n</ol>\n<p>На самом деле, 95% этой задачи решаются очень быстро. Достаточно найти место в базе данных, где хранятся соответствия таблицы -> типа данных -> домена и сделать селект. (Благо, в БД SAP хранится <strong>ВСЁ</strong>, включая программный код)</p>\n<p>Методом скоростного гугления обнаруживаем две таблицы, которые нам в этом могут помочь:</p>\n<ol>\n<li><strong>dd03l</strong> — соответствие: таблица - поле - тип данных - домен</li>\n<li><strong>dd02l</strong> — соответствие: таблица - класс таблицы (нас не интересуют объявленные типы таблиц, которые <strong>не</strong> используются в БД)</li>\n</ol>\n<p>Ну и простейший селект из них:</p>\n<pre><code class=\"language-abap\">SELECT DISTINCT dd03l~domname dd03l~rollname dd03l~fieldname\n    dd03l~tabname\n  INTO CORRESPONDING FIELDS OF TABLE rt_tables\n  FROM dd03l JOIN dd02l\n    ON dd03l~tabname = dd02l~tabname AND\n      dd03l~as4local = dd02l~as4local\n  WHERE\n    dd03l~domname IN ir_domains AND\n    \" Активные\n    dd03l~as4local = 'A' AND\n    \" Таблицы, которые используются в СУБД\n    dd02l~tabclass IN ('TRANSP', 'CLUSTER', 'POOL').\n</code></pre>\n<p>Проверка количества записей делается самым очевидным способом: <strong>select count(*)</strong> в цикле по всем таблицам.</p>\n<pre><code class=\"language-abap\">LOOP AT lt_tables ASSIGNING &#x3C;ls_table>.\n  SELECT SINGLE COUNT(*)\n    FROM (&#x3C;ls_table>-tabname)\n    INTO lv_records_count.\n\n  \" [ .... ]\nENDLOOP.\n</code></pre>\n<p>Казалось бы, что может пойти не так? Всего лишь осталось реализовать проверку таблицы на пустоту, не делая select count(*) по всей таблице. </p>\n<p>Поскольку за выполнение запросов напрямую в <strong>БД</strong>, минуя прослойку <strong>ABAP</strong> — абаперов бьют по рукам (особенно при миграции на другую <em>СУБД</em>). Разработчикам приходится довольствоваться куцым подмножеством <strong>sql</strong>, который предоставляет ABAP API. В нём напрочь отсутствует не только <em>database-specific-features</em>, но и вполне стандартные вещи типа вложенных запросов.</p>\n<p>Т.е. вот такой простой и понятный запрос у нас ни за что не выполнится:</p>\n<pre><code class=\"language-sql\">select count(*) \nfrom (select top 1 * \n      from TABLE)\n</code></pre>\n<p>Приходится изобретать велосипед. И единственным выходом в этой ситуации будет попытка сделать селект <strong>хотя бы одной</strong> записи из таблицы и проверка на успех.</p>\n<p>Сказано-сделано:</p>\n<pre><code class=\"language-abap\">LOOP AT lt_tables ASSIGNING &#x3C;ls_table>.\n  SELECT SINGLE *\n    FROM (&#x3C;ls_table>-tabname)\n    INTO \" ...\n  \" Так, стоп. А куда присваивать значение?\n  \" [ .... ]\nENDLOOP.\n</code></pre>\n<p>Блок <strong>into %var%</strong> пропустить нельзя. Без него компиллятор сваливается с ошибкой. (Про ABAP-подобие байткода как-нибудь в другой раз)</p>\n<p>А куда присваивать значения, если заранее неизвестен тип данных? В <strong>ABAP</strong> таких \"безразмерных\" типов нет. Так что придется как-то объявлять переменные в рантайме. Но с этим не всё так гладко! :)</p>\n<h2>Длинное отступление про принцип объявления переменных в ABAP</h2>\n<p>Казалось бы, о чем здесь рассказывать? Почти каждый относительно-высокоуровневый язык предоставляет очень простой <em>API</em> для объявления переменных. </p>\n<p>В данном случае, переменные объявляются ключевым словом <strong>DATA</strong>, далее идет указание имени переменной и её тип:</p>\n<pre><code class=\"language-abap\">data some_name type string.\n</code></pre>\n<p>Но, поскольку <em>abap</em> — достаточно старый язык, он тянет за собой весьма странное легаси-поведение, которое в современном мире кажется моветоном. Например:</p>\n<pre><code class=\"language-abap\">if 1 = 1.\n    data some_string type string.\n    some_string = 'hello world'.\nendif.\n\nwrite some_string.\n</code></pre>\n<p>Уважаемые знатоки, внимание вопрос: выполнится ли этот код без ошибки? И выведется ли <em>hello world?</em><br>\nПравильные ответы: <strong>да и да</strong>.</p>\n<p>Если вы на секунду подумали, что объявление переменных в <em>abap</em> ведет себя так же, как ключевое слово <strong>var</strong> в <em>JavaScript</em>, и переменная <em>\"вываливается\"</em> за текущий блок, то спешу вас разочаровать... </p>\n<pre><code class=\"language-abap\">if 1 = 2.\n    \" Никогда не выполнится\n    data some_string type string.\nendif.\n\nsome_string = 'hello world'.\nwrite some_string. \"hello world \n\"(да, это работает)\n</code></pre>\n<p>Несмотря на то, что выполнение основного интерпретатора программы <strong>никогда</strong> не зайдёт в блок <strong>IF</strong>, переменная всё равно объявится!</p>\n<p><strong>N.B.</strong>: перед выполнением кода, его быстренько пробегает интерпретатор и выделяет память под <strong>все</strong> используемые переменные в этой подпрограмме/методе.</p>\n<p>А объявленные переменные будут доступны в <strong>любом месте</strong> внутри метода/подпрограммы.</p>\n<p>На самом деле, это больше похоже на хостинг функций в <em>JavaScript</em>. <a href=\"https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5\">Который хорошо описан здесь.</a></p>\n<p>Значит ли это, <del>что всё предопределено</del> что мы не можем выделять память в рантайме, когда на момент компилляции неизвестен тип? </p>\n<p>И да, и нет. Саму переменную всё-таки придется объявить в виде ссылки на \"какую-то\" область памяти. А под неё уточнить тип и выделить память мы можем тогда, когда нам это потребуется. Выглядит это следующим образом:</p>\n<pre><code class=\"language-abap\">\" Создаём переменную как ссылку на \"какие-то\" данные\ndata my_var type ref to data.\n\" Выделяем память под нужный тип данных\ncreate data my_var type ('typename').\n</code></pre>\n<p>Это, конечно, прекрасно. Но так просто обращаться к этой области памяти и записывать/читать данные у нас не получится! :) Для этого нам потребуется познакомиться с ещё одним abap-концептом.</p>\n<p>Это <strong>field-symbols</strong> — ссылки на уже <strong>объявленные</strong> переменные или строки таблицы. В примерах выше, где я делал цикл по таблице, я уже использовал <em>field-symbol</em>, куда присваивал адрес \"текущей\" строки в итерации цикла.</p>\n<pre><code class=\"language-abap\">loop at table assigning &#x3C;field-symbol>.\n\" do some shit with &#x3C;field-symbol>\nendloop.\n</code></pre>\n<p>Аналогичное действие придется выполнить и сейчас, чтобы полноценно воспользоваться выделенной памятью, как переменной:</p>\n<pre><code class=\"language-abap\">data my_var type ref to data.\n\" field-symbol можно объявлять с типом any\nfield-symbols &#x3C;link_to_data> type any.\n\ncreate data my_var type ('typename').\nassign my_var->* to &#x3C;link_to_data>.\n\n\" do some shit with &#x3C;link_to_data>\n</code></pre>\n<h2>Финишная прямая:</h2>\n<p>Прикручиваем эти концепты к нашей задаче:</p>\n<pre><code class=\"language-abap\">FIELD-SYMBOLS: &#x3C;lv_temp>  TYPE ANY.\nDATA lo_data TYPE REF TO data.\n\nLOOP AT it_tables ASSIGNING &#x3C;ls_table>.\n  \n  CREATE DATA lo_data TYPE (&#x3C;ls_table>-rollname).\n  ASSIGN lo_data->* TO &#x3C;lv_temp>.\n\n  SELECT SINGLE (&#x3C;ls_table>-fieldname)\n    FROM (&#x3C;ls_table>-tabname)\n    INTO &#x3C;lv_temp>.\n\n  \"sy-subrc аналог return-code в bash\n  IF sy-subrc = 0.\n    \" Обработка успешного селекта\n  ELSE.\n    \" Обработка пустой таблицы\n  ENDIF.\nENDLOOP.\n</code></pre>\n<h2>Заключение</h2>\n<p>Внезапно этот костыль компилируется и работает. За очисткой данных можно не следить, т.к. за нас её выполнит сборщик мусора. Нам остаётся красиво нарисовать результаты пользователю, но это уже совсем другая история.</p>\n<p>Вот именно таким образом тривиальные задачи усложняются внутри abap во много раз из-за излишних синтаксических ограничений. </p>\n<p>Например, если бы было возможно выполнить вложенный <em>sql</em> или исключить блок \"into\" в запросах, то не пришлось бы в цикле выделять много памяти под абсолютно ненужную переменную, которая никак не обрабатывается в дальнейшем. </p>\n<p>(Кстати, создавая потенциальную утечку памяти, т.к. никто не знает, насколько качественно отрабатывает сборщик мусора)</p>\n<p>На этом всё. Всех благ. :)</p>\n","ogImage":{"url":"/assets/blog/domain_where_used_list/background.jpg"},"coverImage":"/assets/blog/domain_where_used_list/background.jpg","issueId":"13"}},"__N_SSG":true}