{"pageProps":{"post":{"title":"Класс для удобного манипулирования датами в ABAP","date":"2020-05-24T14:15:07.322Z","slug":"zcl-date-abap","author":{"name":"Roman A. Nosov","picture":"/assets/blog/authors/romannosov.png"},"content":"<p>Настало время делиться своей болью и страданиями. Меня зовут Носов Роман, и, мне очень стыдно в этом признаться, но я <del>алкоголик</del> иногда пишу на <em>ABAP</em>, чтобы не умереть с голоду.</p>\n<p><strong>Для тех, кто в танке и никогда не слышал, что это такое:</strong> <em>ABAP</em> -- это внутренний язык, на котором программируют (допиливают напильником) разные продукты от <em>SAP</em> . От допиливаний страдают, как сама система, так и программисты с пользователями. И всё действо со стороны больше напоминает истязания грешников в каком-нибудь круге ада по Данте.</p>\n<p>А <strong>SAP</strong> в свою очередь -- <del>очень дорогая немецкая одинэска</del> компания которая делает ERP системы для крупных бизнесов.</p>\n<p>Как сказал неизвестный мудрец в комментариях на хабре:\n<img src=\"/assets/blog/zcl_date_abap/stalingrad.png\" alt=\"SAP -- это месть Гитлера за Сталинград\"></p>\n<h2>И тут мне захотелось немного уменьшить градус боли (по части работы с датами)</h2>\n<h3>Для начала немного теории:</h3>\n<p>В <em>ABAP</em> для хранения даты встроен специальный тип данных -- <em>DATS</em> (или сокращенно -- <em>D</em>). Представляет он из себя строку из 8 символов, в которой хранится по порядку: год,месяц,день. </p>\n<p><strong>Например:</strong> '20190102' -- это второе января 2019 года.</p>\n<p>Так же, для этого типа данных перегружены действия + и -. Которые отнимают и прибавляют дни к дате, или считают разницу в днях между двумя датами.</p>\n<pre><code class=\"language-abap\">DATA: lv_dats  TYPE dats,\n      lv_dats2 TYPE dats,\n      lv_int   TYPE i.\n\n\" -/+ между dats и int возвращает dats с отнятыми/прибавленными днями\nlv_dats = '20190102'.\nlv_dats = lv_dats - 5.\nWRITE lv_dats. \" 28.12.2018\n\n\" -/+ между dats и dats возвращает int -- разница между датами в днях\nlv_dats2 = '20190101'.\nlv_int = lv_dats2 - lv_dats. \" 01.01.2019 -  28.12.2018\nWRITE lv_int. \" 4\n</code></pre>\n<p>Но что делать, если очень хочется сделать инкремент месяца (не + 30 дней, а именно получить то же число следующего месяца, независимо от длины месяца (28-31))?</p>\n<p>Для этого есть громоздкий функциональный модуль RP_CALC_DATE_IN_INTERVAL. Умеет складывать/отнимать годы/месяцы/дни и возвращает валидную дату. </p>\n<pre><code class=\"language-abap\">DATA: lv_dats  TYPE dats.\n\nlv_dats = '20190215'. \" 15.02.2019\n\nCALL FUNCTION 'RP_CALC_DATE_IN_INTERVAL'\n  EXPORTING\n    date      = lv_dats\n    days      = 0\n    months    = 1\n    signum    = '+'\n    years     = 0\n  IMPORTING\n    calc_date = lv_dats.\n\nwrite lv_dats. \" Искомое 15 марта\n</code></pre>\n<p>Но вы точно хотите использовать в своих программах вот такие уродливые конструкции?</p>\n<p>Отдельным пунктиком следует упомянуть про развлечения программистов с красивым форматированием даты. Огромные полотна кода с выдёргиваниями подстрок из даты, и конкатенации в нормальном виде.\n<a href=\"https://www.erpworkbench.com/abap/date/date_format.htm\" title=\"Formatting SAP date field using ABAP\">Пример</a></p>\n<p>А если очень хочется вместо номера месяца видеть его название? Май, апрель....</p>\n<p>А если очень хочется видеть названия месяцев на том языке, на котором запущен SAP? :)\nОгромные просторы для танцев с бубном и изобретаний велосипедов!</p>\n<h2>Z* разработки в SAP -- бесконечная фабрика велосипедов</h2>\n<p><img src=\"/assets/blog/zcl_date_abap/meme.jpg\" alt=\"worst proramming language\"></p>\n<p>Итак, нам нужен класс, который мог инкапсулировать в себе стандартный dats, но предоставлять удобный <em>API</em> для работы с датами, максимально скрывая уродливость языка <em>ABAP</em>.</p>\n<p>Он должен уметь:</p>\n<ol>\n<li>Прибавлять дни/месяцы/годы к текущей дате</li>\n<li>Иметь адекватные геттеры/сеттеры для дней/месяцев/годов, скрывая работу с подстроками</li>\n<li>Получать названия месяцев на заданном языке</li>\n<li>Метод <em>to_string</em>, который возвращает строковое представление даты по заданной маске <em>(like printf)</em></li>\n</ol>\n<h2>Реализация:</h2>\n<p>Создаём класс. В его свойствах будем хранить:</p>\n<ol>\n<li>Язык, который будет передаваться в конструкторе -- (по умолчанию -- язык системы)</li>\n<li>Дата, которая аналогично будет передаваться в конструкторе -- (по умолчанию -- текущая)</li>\n<li>Таблица названий месяцев для выбранного пользователем языка</li>\n<li>Константы для метода to_string( )</li>\n</ol>\n<pre><code class=\"language-abap\">  DATA:\n    gt_month_names TYPE STANDARD TABLE OF t247 .\n  DATA gv_language TYPE lang .\n  DATA gv_date TYPE dats .\n  CONSTANTS nv_long_year TYPE string VALUE '$yyyy'.       \n  CONSTANTS nv_short_year TYPE string VALUE '$yy'.        \n  CONSTANTS nv_month_name TYPE string VALUE '$m'.         \n  CONSTANTS nv_short_month_name TYPE string VALUE '$mmm'. \n  CONSTANTS nv_month_number TYPE string VALUE '$mm'.      \n  CONSTANTS nv_day TYPE string VALUE '$dd'.               \n</code></pre>\n<p><strong>Конструктор и статический метод create</strong></p>\n<pre><code class=\"language-abap\">  \" Просто присваиваем значения \n  METHOD constructor.\n    gv_language = iv_language.\n    gv_date = iv_date.\n  ENDMETHOD.\n\n  METHOD create. \" Что-то отдалённо похожее на фабричный метод,\n  \" только возвращаем инстанс самого класса zcl_date. \n  \" Таким образом избавляемся от громоздкой конструкции create object*\n  \n    CREATE OBJECT ro_instance\n      EXPORTING\n        iv_date     = iv_date\n        iv_language = iv_language.\n  ENDMETHOD.\n</code></pre>\n<p>Прибавлять и вычитать будем уже известным функциональным модулем <em>RP_CALC_DATE_IN_INTERVAL</em>, но спрячем его поглубже, чтобы не было так страшно. Наружу (public) будут торчать два минималистичных метода: plus/minus</p>\n<pre><code class=\"language-abap\">  METHOD date_calculation.\n    CALL FUNCTION 'RP_CALC_DATE_IN_INTERVAL'\n      EXPORTING\n        date      = gv_date\n        days      = iv_days\n        months    = iv_months\n        signum    = iv_sign\n        years     = iv_years\n      IMPORTING\n        calc_date = gv_date.\n  ENDMETHOD.\n\n  METHOD minus.\n    date_calculation( iv_days   = iv_days\n                      iv_months = iv_months\n                      iv_years  = iv_years\n                      iv_sign   = '-' ).\n  ENDMETHOD.\n\n  METHOD plus.\n    date_calculation( iv_days   = iv_days\n                      iv_months = iv_months\n                      iv_years  = iv_years\n                      iv_sign   = '+' ).\n  ENDMETHOD.\n</code></pre>\n<p>Получать названия месяцев на текущем языке будем с помощью ФМ <em>MONTH_NAMES_GET</em>, который будем дёргать тогда, когда осознаем, что для этого языка у нас нет названий.</p>\n<pre><code class=\"language-abap\">  METHOD init_month_names.\n    CALL FUNCTION 'MONTH_NAMES_GET'\n      EXPORTING\n        language              = gv_language\n      TABLES\n        month_names           = gt_month_names\n      EXCEPTIONS\n        month_names_not_found = 1\n        OTHERS                = 2.\n  ENDMETHOD.\n\n  METHOD get_month_name_by_number.\n    DATA ls_month LIKE LINE OF gt_month_names.\n  \n    \" Есть ли вообще записи для текущего языка?\n    READ TABLE gt_month_names\n      INTO ls_month\n      WITH KEY spras = gv_language.\n  \n    IF sy-subrc &#x3C;> 0.\n      init_month_names( ).\n    ENDIF.\n  \n    CLEAR ls_month.\n    READ TABLE gt_month_names\n      INTO ls_month\n      WITH KEY\n        mnr   = iv_number\n        spras = gv_language.\n  \n    rv_month_name = ls_month-ltx.\n  ENDMETHOD.\n</code></pre>\n<p>Ну и метод to_string( ). Который заменяет ключевые слова в маске значениями.</p>\n<pre><code class=\"language-abap\">  METHOD to_string.\n    DATA:\n      lv_day              TYPE num2,\n      lv_month_name       TYPE string,\n      lv_month_number     TYPE num2,\n      lv_short_month_name TYPE string,\n      lv_short_year       TYPE num2,\n      lv_long_year        TYPE num4.\n\n    lv_day = get_day( ).\n    lv_month_name = get_month_name( ).\n    lv_month_number = get_month_number( ).\n    lv_short_month_name = get_short_month_name( ).\n    lv_short_year = get_short_year( ).\n    lv_long_year = get_year( ).\n\n    \" year\n    REPLACE ALL OCCURRENCES OF nv_long_year IN iv_format WITH lv_long_year IGNORING CASE.\n    REPLACE ALL OCCURRENCES OF nv_short_year IN iv_format WITH lv_short_year IGNORING CASE.\n\n    \" month\n    REPLACE ALL OCCURRENCES OF nv_short_month_name IN iv_format WITH lv_short_month_name IGNORING CASE.\n    REPLACE ALL OCCURRENCES OF nv_month_number IN iv_format WITH lv_month_number IGNORING CASE.\n    REPLACE ALL OCCURRENCES OF nv_month_name IN iv_format WITH lv_month_name IGNORING CASE.\n\n    \"day\n    REPLACE ALL OCCURRENCES OF nv_day IN iv_format WITH lv_day IGNORING CASE.\n\n    rv_string = iv_format.\n  ENDMETHOD.\n</code></pre>\n<p>Осталось прикрутить геттеры/сеттеры. и доработать API.</p>\n<p>Что в итоге получилось -- можно посмотреть здесь: <a href=\"https://github.com/JustAddAcid/abap_date/\" title=\"Класс для удобного использования даты в abap\">github.com/JustAddAcid/abap_date</a></p>\n<h2>Результаты</h2>\n<ol>\n<li>Минималистичные методы plus/minus</li>\n</ol>\n<pre><code class=\"language-abap\">lo_date = zcl_date=>create( '20200101' ). \" 01.01.2020\n\nlo_date->minus( iv_years = 2 ). \" 01.01.2018\nlo_date->plus( iv_days = 3 ).   \"04.01.2018\nlo_date->plus( iv_months = 1 ). \"04.02.2018\n\n\" Несколько аргументов\nlo_date->plus( \n    iv_days  = 1\n    iv_years = 2\n). \" 05.02.2020\n</code></pre>\n<ol start=\"2\">\n<li>Геттеры/сеттеры</li>\n<li>Метод get_month_name( ), получающий названия месяца</li>\n</ol>\n<pre><code class=\"language-abap\">data: lo_date  type ref to zcl_date,\n      lv_dats  type dats,\n      lv_month type string.\n\nlo_date = zcl_date=>create( ).\nlo_date->set_year( 2001 ).\nlo_date->set_month_number( 9 ).\nlo_date->set_day( 11 ).\n\nlv_dats = lo_date->get_date( ).\nlv_month = lo_date->get_month_name( ).\n\nwrite lv_dats. \" 11 сентября 2001\nwrite lv_month. \" Сентябрь\n</code></pre>\n<ol start=\"4\">\n<li>Метод to_string( ), возвращающий строковое представление даты по маске</li>\n</ol>\n<pre><code class=\"language-abap\">data: lo_date     type ref to zcl_date,\n      lv_formated type string.\n\nlo_date = zcl_date=>create( '20200101' ). \" 01.01.2020\nlv_formated = lo_date->to_string( 'Месяц: $m Год: $yyyy День: $dd' ).\n\nwrite lv_formated. \" Месяц: Январь Год: 2020 День: 01\n</code></pre>\n","ogImage":{"url":"/assets/blog/zcl_date_abap/cover.png"},"coverImage":"/assets/blog/zcl_date_abap/cover.png","issueId":"8"}},"__N_SSG":true}